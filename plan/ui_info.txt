작성해 드린 UI(`HTML/CSS`)의 각 요소에 대한 상세 명세서입니다.
이 문서는 개발 시 **기능 명세서(Functional Specification)**로 활용할 수 있도록, 각 인풋의 **용도**, **작동 로직**, **유효성 검사(Validation)**, 그리고 **설계 의도(Rationale)**를 기술적으로 정리했습니다.

---

### 1. 상단 헤더 영역 (Header & Mode)

#### 1.1 모드 전환 탭 (Tab Switch)
* **UI 요소:** `<div>` (Clickable)
* **용도:** 어플리케이션의 **작동 컨텍스트(Context)**를 전환합니다.
    * `📡 화면 공유 모드`: `navigator.mediaDevices.getDisplayMedia()` API 사용.
    * `📂 로컬 파일 분석`: `<input type="file">` 및 `<video>` 태그 사용.
* **적용 로직:**
    * 탭 변경 시 전역 상태(State)인 `currentMode`를 변경합니다.
    * **UI 분기:** 로컬 파일 모드에서는 '재생 속도 조절', '탐색 바(Seek bar)'가 활성화되지만, 화면 공유 모드에서는 이를 숨기고 '녹화 시작/중지' 버튼과 '타이머'를 노출합니다.
* **설계 의도:** 두 모드는 제어 가능한 범위(재생 속도 조절 가능 여부 등)가 완전히 다르므로, UI를 물리적으로 분리하여 사용자 혼동을 방지했습니다.

---

### 2. 좌측 패널: 설정 및 제어 (Control Panel)

#### 2.1 파일 열기 / 공유 시작 버튼
* **UI 요소:** `<button>`, 숨겨진 `<input type="file" accept="video/*">`
* **용도:** 분석할 미디어 소스를 로드합니다.
* **유효성 검사:**
    * **파일 형식:** `video/mp4`, `video/webm` 등 브라우저가 기본 지원하는 포맷인지 확인.
    * **용량 제한:** 클라이언트 사이드 처리는 용량 제한이 없으나, 브라우저 메모리 보호를 위해 2GB 이상 파일 로드 시 경고(Warning) 모달 띄움.
* **로직:**
    * 파일 선택 시 `URL.createObjectURL(file)`을 통해 Blob URL을 생성하여 비디오 태그의 `src`에 할당합니다. (메모리 효율성)

#### 2.2 재생 속도 (Playback Rate)
* **UI 요소:** `<select>` (1.0x ~ 4.0x)
* **용도:** 영상 재생 속도를 조절하여 OCR 처리 속도와 정확도 간의 균형을 맞춥니다.
* **로직:**
    * 변경 시 `videoElement.playbackRate = value` 실행.
    * **주의:** 속도가 빠를수록 프레임 스킵이 발생할 수 있으므로, 2배속 이상 설정 시 "OCR 누락이 발생할 수 있습니다"라는 **Toaster 알림**을 띄웁니다.

#### 2.3 최소 주기 (Capture Interval)
* **UI 요소:** `<input type="number">` (단위: ms)
* **용도:** OCR 엔진을 실행할 최소 시간 간격을 설정합니다. (기본값: 1000ms)
* **유효성 검사:**
    * **최소값 제한:** `min="100"`. 100ms 미만 입력 시 브라우저 메인 스레드 동결(Freezing) 방지를 위해 강제로 100으로 보정하거나 경고 표시.
    * **입력 타입:** 숫자만 허용.
* **설계 의도:** 사용자의 CPU 성능에 따라 조절할 수 있게 합니다. 성능이 낮은 PC에서는 주기를 늘려 멈춤 현상을 방지합니다.

#### 2.4 민감도 (Sensitivity)
* **UI 요소:** `<input type="range">` (Slider, 1~100)
* **용도:** 이전 프레임과 현재 프레임이 얼마나 다를 때 OCR을 수행할지 결정합니다.
* **로직:**
    * ROI 영역의 픽셀 데이터(Pixel Data)를 비교(Diff).
    * 변화량이 설정값 미만이면(화면이 정지해 있거나 변화가 거의 없음) **OCR 연산을 건너뛰어(Skip) 자원을 절약**합니다.
* **설계 의도:** 불필요한 중복 데이터(똑같은 자막이 5초간 떠 있을 때 5번 추출하는 것)를 방지합니다.

#### 2.5 ROI 구조 리스트 (Region of Interest Table)
* **UI 요소:** 테이블(`Key Name` 인풋), 삭제 버튼
* **용도:** 추출할 데이터의 스키마(변수명)를 정의합니다. (예: 화자, 자막, 시간)
* **유효성 검사:**
    * **Key Name 중복 불가:** 이미 존재하는 키 이름 입력 시 테두리를 붉게 표시(Red Border).
    * **특수문자 제한:** JSON 키로 사용되므로 공백이나 특수문자 자동 제거(Sanitization).
* **로직:**
    * `삭제` 클릭 시: 해당 행 삭제 + 우측 비디오 영역의 오버레이 박스(Overlay Box)도 함께 제거.
    * `추가` 로직: 리스트에서 추가하는 것이 아니라, **우측 영상에서 드래그를 완료했을 때** 자동으로 행이 추가되는 **역방향 바인딩**을 권장합니다.

---

### 3. 우측 패널: 영상 및 오버레이 (Video & Overlay)

#### 3.1 비디오 플레이어 & 캔버스 오버레이
* **UI 요소:** `<video>`, 투명 `<canvas>` (z-index가 더 높음)
* **용도:** 영상 재생 및 마우스 드래그를 통한 영역 지정.
* **로직 (핵심 기술):**
    * **좌표 변환 (Coordinate Transform):**
        * 사용자는 CSS로 조정된 화면(`offsetWidth`)에서 드래그하지만, 실제 데이터는 영상 원본 해상도(`videoWidth`) 기준으로 저장해야 합니다.
        * `저장_X = 클릭_X * (videoWidth / offsetWidth)`
        * 이 변환 로직이 없으면 창 크기를 바꿀 때 영역이 엉뚱한 곳으로 튀게 됩니다.
    * **드래그 앤 드롭:**
        * `mousedown`: 시작 좌표 기록.
        * `mousemove`: 임시 박스 그리기 (점선).
        * `mouseup`: 최종 좌표 확정 → **"이 영역의 이름은 무엇입니까?" (Prompt/Modal)** 호출 → 좌측 ROI 리스트에 추가.
* **유효성 검사:**
    * **최소 면적 제한:** 10x10px 미만의 드래그는 실수로 간주하여 무시.
    * **영역 이탈 방지:** 비디오 밖으로 마우스가 나가면 비디오 경계값(Max Width/Height)으로 좌표 고정(Clamping).

---

### 4. 하단 패널: 결과 데이터 (Results Console)

#### 4.1 결과 테이블 (Data Grid)
* **UI 요소:** `<table>`, `contenteditable` 셀
* **용도:** 추출된 데이터를 실시간으로 보여주고, 오타를 수정합니다.
* **로직:**
    * **Auto Scroll:** 새로운 데이터가 들어오면 자동으로 스크롤을 최하단으로 이동. (사용자가 스크롤을 위로 올리면 일시 정지).
    * **데이터 바인딩:** 셀의 텍스트를 수정하면, 메모리 내의 데이터 배열(`extractedData[]`)도 즉시 업데이트되어야 합니다. (다운로드 시 수정본 반영).
* **설계 의도:** OCR은 100% 완벽할 수 없습니다. 따라서 **"수정 가능한(Editable) UI"**가 필수적입니다.

#### 4.2 다운로드 버튼
* **UI 요소:** `<button>` (JSON, CSV)
* **용도:** 결과물 내보내기.
* **로직:**
    * 메모리 내의 객체 배열을 문자열로 직렬화(Serialization).
    * `Blob` 객체 생성 후 `<a>` 태그를 동적 생성하여 클릭 트리거.
* **유효성 검사:**
    * 추출된 데이터가 0건일 경우 버튼 비활성화(Disabled).

---

### 5. 종합 요약: 왜 이렇게 설계했는가?

1.  **성능 최적화 (Performance):**
    * 모든 로직이 클라이언트 브라우저에서 돕니다. 따라서 `민감도(Sensitivity)`와 `최소 주기(Interval)` 설정은 사용자가 자신의 PC 성능에 맞춰 **직접 튜닝**할 수 있도록 반드시 노출되어야 합니다.
2.  **데이터 무결성 (Integrity):**
    * 영상 크기가 변해도 좌표가 유지되도록 **"비율 기반 좌표 변환"** 로직이 UI 뒤단에 숨어 있어야 합니다.
    * JSON 키값의 중복을 막는 유효성 검사는 최종 데이터 구조가 깨지는 것을 방지합니다.
3.  **사용자 경험 (UX):**
    * **"좌측 리스트 추가 → 우측 좌표 설정"** 방식은 불편합니다.
    * **"우측에서 직관적으로 드래그 → 좌측에 자동 등록"** 흐름을 채택하여 작업 속도를 높였습니다.